<?xml version="1.0" encoding="ISO-8859-1"?>
<!--
  ~ Copyright (c) 2014, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
  ~
  ~ WSO2 Inc. licenses this file to you under the Apache License,
  ~ Version 2.0 (the "License"); you may not use this file except
  ~ in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~    http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing,
  ~ software distributed under the License is distributed on an
  ~ "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  ~ KIND, either express or implied. See the License for the
  ~ specific language governing permissions and limitations
  ~ under the License.
  -->

<!-- This is the root configuration file of WSO2 Message Broker. Links to configurations of associated libraries are also specified here.
[developer-advice] - If you intend to rename or modify a property, remember to search in the code using the Xpath expression of the property. -->
<broker>

    <!--Paths of externally organized configurations specific to Andes component (Qpid configurations are referred 
    by Qpid component separately. (MB_HOME/repository/conf/advanced/qpid-config.xml)-->
    <links>
    </links>

    <coordination>
        <!-- You can override the cluster node identifier of this MB node using the nodeID. If it is left as "default",
       the default node ID will be generated for it. (Using IP + UUID).
       The node ID of each member should ALWAYS be unique.-->
        <nodeID>default</nodeID>

        <!-- Thrift is used to maintain and sync slot (message groups) ranges between MB nodes. -->
        <thriftServerHost>localhost</thriftServerHost>
        <thriftServerPort>7611</thriftServerPort>
    </coordination>

    <!-- You can enable/disable specific messaging transports in this section. By default all transports are enabled.
    This section also allows you to customize the messaging flows used within WSO2 MB. NOT performance related, but logic related. -->
    <transports>
        <!-- If you need to provide a specific IP with which the messaging transports should happen, change this.
        By default, this takes the IP of the resident node. Please note that this is the address exposed by
        the server. NOT the hostname inferred from carbon.xml -->
        <bindAddress>127.0.0.1</bindAddress>

        <amqp enabled="true">
            <!-- most of the AMQP configurations reside in qpid-config.xml since we inherit the Qpid messaging model during AMQP.-->
            <port>5672</port>
            <sslPort>8672</sslPort>
            <sendExpiredMessagesToDLC>false</sendExpiredMessagesToDLC>
            <maximumRedeliveryAttempts>10</maximumRedeliveryAttempts>
            <allowSharedTopicSubscriptions>false</allowSharedTopicSubscriptions>
        </amqp>
        <mqtt enabled="true">
            <port>1883</port>
            <sslPort>8883</sslPort> <!-- put proper default ssl port -->

            <!-- These two properties are temporary. Ideally, MQTT should use carbon users. -->
            <users>
                <user userName="testuser1" password="password1" />
                <user userName="testuser2" password="password2" />
            </users>
        </mqtt>

    </transports>

    <!-- Depending on the database type selected in master-datasources.xml, you must enable the relevant Data access classes here.
    Currently supported stores are JDBC(any RDBMS store) and Cassandra(CQL, Hector).
    Any data store is accessed for 2 purposes. 1. For message persistence ("messageStore")
    2. To persist and access other information relevant to messaging protocols.("contextStore").-->

    <!-- By default WSO2 MB runs with full in memory store using H2. If you plan to use a different store, set "inMemory" to "false"-->
    <persistence>

        <!-- H2 Based MB Store Configuration -->

        <messageStore class="org.wso2.andes.store.jdbc.JDBCMessageStoreImpl">
            <property name="dataSource">WSO2MBStoreDB</property>
        </messageStore>

        <contextStore class="org.wso2.andes.store.jdbc.JDBCAndesContextStoreImpl">
            <property name="dataSource">WSO2MBStoreDB</property>
        </contextStore>


        <!-- H2 Based In-Memory Store Configuration -->
<!--         
        <messageStore class="org.wso2.andes.store.jdbc.h2.H2MemMessageStoreImpl">
        </messageStore>

        <contextStore class="org.wso2.andes.store.jdbc.h2.H2MemAndesContextStoreImpl">
        </contextStore>

-->

        <!-- External Cassandra Store Configuration -->

        <!-- NOTE: Update the master-datasources.xml file to connect to Cassandra data source
             READ the documentation to set advanced Cassandra tuning parameters.

            Advanced Tuning Parameters

            Replication strategy class:
            Strategy to determines the physical location of nodes to replication and their proximity to each other

            Replication factor:
            replication is the process of storing copies of data on multiple nodes to ensure reliability and fault tolerance.

            Read consistency level:
            Specifies how many replicas must respond to a read request before returning data
            Valid values are 'ONE','ALL','EACH_QUORUM','QUORUM','ONE','TWO','THREE','ANY'

            Write consistency level:
            Determines the number of replicas on which the write must succeed before returning an acknowledgement
            Valid values are 'ONE','ALL','EACH_QUORUM','QUORUM','ONE','TWO','THREE','ANY' -->

        <!--CQL Based MB stores-->
<!--
        <messageStore class="org.wso2.andes.store.cassandra.cql.CQLBasedMessageStoreImpl">
            <property name="dataSource">WSO2MBStoreDB</property>
            <property name="strategyClass">org.apache.cassandra.locator.SimpleStrategy</property>
            <property name="replicationFactor">1</property>
            <property name="readConsistencyLevel">ONE</property>
            <property name="writeConsistencyLevel">ONE</property>
        </messageStore>

        <contextStore class="org.wso2.andes.store.cassandra.cql.CQLBasedAndesContextStoreImpl">
            <property name="dataSource">WSO2MBStoreDB</property>
            <property name="strategyClass">org.apache.cassandra.locator.SimpleStrategy</property>
            <property name="replicationFactor">1</property>
            <property name="readConsistencyLevel">ONE</property>
            <property name="writeConsistencyLevel">ONE</property>
        </contextStore>
-->

        <!--Hector based MB stores-->
<!--
        <messageStore class="org.wso2.andes.store.cassandra.hector.HectorBasedMessageStoreImpl">
            <property name="dataSource">WSO2MBStoreDB</property>
            <property name="strategyClass">org.apache.cassandra.locator.SimpleStrategy</property>
            <property name="replicationFactor">1</property>
            <property name="readConsistencyLevel">ONE</property>
            <property name="writeConsistencyLevel">ONE</property>
        </messageStore>

        <contextStore class="org.wso2.andes.store.cassandra.hector.HectorBasedAndesContextStoreImpl">
            <property name="dataSource">WSO2MBStoreDB</property>
            <property name="strategyClass">org.apache.cassandra.locator.SimpleStrategy</property>
            <property name="replicationFactor">1</property>
            <property name="readConsistencyLevel">ONE</property>
            <property name="writeConsistencyLevel">ONE</property>
        </contextStore>
-->

        <!-- This class decides how unique IDs are generated for messages that are persisted -->
        <idGenerator>org.wso2.andes.server.cluster.coordination.TimeStampBasedMessageIdGenerator</idGenerator>
    </persistence>

    <!-- Alter the flow that is triggered during a node fail -->
    <failoverBehaviour>

    </failoverBehaviour>

    <!-- This section allows you to tweak memory and processor allocations used by WSO2 MB.
    Broken down by critical processes so you have a clear view of which parameters to change in different scenarios.  -->
    <performanceTuning>

        <slots>
            <!--maximum time interval where slot can be retain in memory before updating to the cluster(in milliseconds)-->
            <slotRetainTimeInMemory>1000</slotRetainTimeInMemory>

            <!--rough estimate for size of a slot-->
            <windowSize>1000</windowSize>

            <!--Number of SlotDeliveryWorker threads that should be started-->
            <workerThreadCount>5</workerThreadCount>
        </slots>

        <delivery>
            <!-- Maximum number of undelivered messages that can have in memory. Increasing this value
                increase the possibility of out of memory scenario but performance will be improved-->
            <maxNumberOfReadButUndeliveredMessages>1000</maxNumberOfReadButUndeliveredMessages>

            <!-- This is the Thread pool size which will be used by the queue delivery workers.
             Make this to a higher number if there are lots of unique queues to the system at a given time. -->
            <publisherPoolSize>50</publisherPoolSize>

            <!-- This is the ring buffer size of the delivery disruptor. This value should be a power of 2 (E.g. 1024, 2048, 4096).
                 Use a small ring size if you want to reduce the memory usage. -->
            <ringBufferSize>4096</ringBufferSize>

            <!--Number of parallel readers used to used to read content from message store. Increasing this value will
                speed-up the message sending mechanism. But the load on the data store will increase. -->
            <parallelContentReaders>5</parallelContentReaders>

            <!-- Number of parallel delivery handlers used to send messages to subscribers. Increasing this value will
                 speed-up the message sending mechanism. But the system load will increase. -->
            <parallelDeliveryHandlers>5</parallelDeliveryHandlers>
        </delivery>

        <!-- Add any store access related tuning parameters. This should ideally be empty since we handle database level 
        tuning in master-datasources.xml. But in case we have generic aspects to tune, add here. -->
        <storeOperations>
            <!-- This property. are we using it ? the class that uses this property is unused. -->
            <messageContentCache>100</messageContentCache>
        </storeOperations>

        <ackHandling>
            <!-- message delivery from server to the client will be paused temporarily if number of delivered but unacknowledged 
            message count reaches this size. Should be set considering message consume rate-->
            <maxUnackedMessages>1000</maxUnackedMessages>

            <!-- This is the Thread pool size which will be used by the Andes core to schedule its internal parallel tasks -->
            <workerThreadCount>50</workerThreadCount>

            <!--Average batch size of the acknowledgement handler. Andes will batch and process acknowledgements -->
            <ackHandlerBatchSize>100</ackHandlerBatchSize>

            <!--Number of message acknowledgement handlers to process acknowledgements concurrently. These acknowledgement handlers will -->
            <!--batch and process acknowledgements. -->
            <ackHandlerCount>5</ackHandlerCount>

        </ackHandling>

        <inboundEvents>
            <!--Number of parallel writers used to write content to message store. Increasing this value will speed-up-->
            <!--the message receiving mechanism. But the load on the data store will increase.-->
            <parallelMessageWriters>1</parallelMessageWriters>

            <!--Size of the Disruptor ring buffer for inbound event handling. Buffer size should be a value of power -->
            <!--of two. For publishing at higher rates increasing the buffer size may give some advantage -->
            <!--keep messages in memory and write.-->
            <bufferSize>65536</bufferSize>

            <!--Batch size of the state event handler for message written state update -->.
            <!--State events will be handled in batches when updating inbound messages.-->
            <stateHandlerBatchSize>50</stateHandlerBatchSize>

            <!--Average batch size of the batch write operation for inbound messages. Batch write of a message will-->
            <!--vary around this number-->
            <messageWriterBatchSize>70</messageWriterBatchSize>

        </inboundEvents>

        <failover>
            <!-- Virtual host sync interval seconds in for the Virtual host syncing Task which will sync the
                Virtual host details across the cluster -->
            <vHostSyncTaskInterval>3600</vHostSyncTaskInterval>
        </failover>

        <messageExpiration>
            <checkInterval>10000</checkInterval>
            <messageBatchSize>1000</messageBatchSize>
        </messageExpiration>

        <subscriptions>

        </subscriptions>

        <!-- Code specific parameters to ensure messages get deleted as fast as possible without disturbing other processes.-->
        <messageDeletion>

            <!-- This is the Task interval (seconds) for the content removal task which will remove
                    the actual message content from the store in the background. If the message rate is very high users
                    can set this to a lower value -->
            <contentRemovalTaskInterval>4</contentRemovalTaskInterval>

        </messageDeletion>
    </performanceTuning>

    <!-- This section is about how you want to view messaging statistics from the admin console and how you plan to interact with it. -->
    <managementConsole>
        <!--Maximum number of messages to be fetched using Andes message browser when browsing queues-->
        <messageBatchSizeForBrowserSubscriptions>200</messageBatchSizeForBrowserSubscriptions>
    </managementConsole>

    <!-- Memory and resource exhaustion is something we should prevent and recover from.
    This section allows you to specify the threshold at which to reduce/stop frequently intensive operations within MB temporarily. -->
    <flowControl>
        <memoryBased>
            <memoryCheckInterval>20000</memoryCheckInterval>
            <globalMemoryThresholdRatio>0.4</globalMemoryThresholdRatio>
            <globalMemoryRecoveryThresholdRatio>0.5</globalMemoryRecoveryThresholdRatio>
        </memoryBased>
        <connectionBased>
            <perConnectionMessageThreshold>1000</perConnectionMessageThreshold>
        </connectionBased>
    </flowControl>

</broker>
